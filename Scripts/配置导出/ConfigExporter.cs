using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace MiGame.Editor.Exporter
{
    /// <summary>
    /// 所有配置导出器的抽象泛型基类。
    /// T 必须是一个 ScriptableObject。
    /// </summary>
    /// <typeparam name="T">要导出的 ScriptableObject 类型</typeparam>
    public abstract class ConfigExporter<T> : IConfigExporter where T : ScriptableObject
    {
        /// <summary>
        /// 获取此导出器处理的配置类型。
        /// </summary>
        public Type TargetType => typeof(T);

        /// <summary>
        /// 子类必须实现此方法，以指定包含 .asset 文件的目录路径。
        /// 例如: "Assets/GameConf/技能"
        /// </summary>
        /// <returns>资产文件所在的目录路径</returns>
        public abstract string GetAssetPath();

        /// <summary>
        /// 通用的导出方法，使用反射来序列化对象。
        /// </summary>
        /// <param name="exportDir">最终输出Lua文件的目录</param>
        public virtual void Export(string exportDir)
        {
            var allConfigs = FindAssets();
            if (allConfigs == null || allConfigs.Count == 0) return;

            var configName = GetType().Name.Replace("Exporter", "");
            var sb = new StringBuilder();

            // 生成文件头和LuaDoc
            sb.AppendLine($"-- {configName}.lua");
            sb.AppendLine("-- Generated by ConfigExporter. Any custom code will be overwritten.");
            sb.AppendLine();
            sb.AppendLine($"---@class {configName}");
            sb.AppendLine("---@field Data table<string, table>");
            sb.AppendLine();
            sb.AppendLine($"---@type {configName}");
            sb.AppendLine($"local {configName} = {{Data = {{}}}}");
            sb.AppendLine();
            sb.AppendLine("-- --- AUTO GENERATED CONFIG BEGIN ---");
            sb.AppendLine($"{configName}.Data = {{");

            foreach (var config in allConfigs)
            {
                if (config == null) continue;
                sb.AppendLine($"    ['{config.name}'] = {{");
                ObjectToLua(config, sb, 3);
                sb.AppendLine("    },");
            }

            sb.AppendLine("}");
            sb.AppendLine("-- --- AUTO GENERATED CONFIG END ---");
            sb.AppendLine();
            sb.AppendLine($"return {configName}");

            var outputPath = Path.Combine(exportDir, configName + ".lua");
            File.WriteAllText(outputPath, sb.ToString(), Encoding.UTF8);
            UnityEngine.Debug.Log($"导出 {typeof(T).Name} 配置到: {outputPath}");
        }

        /// <summary>
        /// 子类可重写，指定多个包含 .asset 文件的目录路径。
        /// </summary>
        /// <returns>资产文件所在的目录路径数组</returns>
        public virtual string[] GetAssetPaths()
        {
            var single = GetAssetPath();
            return string.IsNullOrEmpty(single) ? new string[0] : new[] { single };
        }

        protected void ObjectToLua(object obj, StringBuilder sb, int indentLevel)
        {
            if (obj == null) return;

            var fields = obj.GetType().GetFields(BindingFlags.Public | BindingFlags.Instance);
            var indent = new string(' ', indentLevel * 2);

            foreach (var field in fields)
            {
                if (Attribute.IsDefined(field, typeof(NonSerializedAttribute)) ||
                    Attribute.IsDefined(field, typeof(ObsoleteAttribute)))
                {
                    continue;
                }

                sb.Append($"{indent}['{field.Name}'] = ");
                ValueToLua(field.GetValue(obj), sb, indentLevel, field.Name);
                sb.AppendLine(",");
            }
        }

        protected void ValueToLua(object value, StringBuilder sb, int indentLevel, string fieldName = null)
        {
            if (value == null)
            {
                sb.Append("nil");
                return;
            }

            var type = value.GetType();
            var indent = new string(' ', indentLevel * 2);

            if (type == typeof(string))
            {
                var stringValue = value.ToString();
                
                // 特殊处理：如果字符串内容是纯数字，则导出为数字类型
                // 但对于超大数字（超过JavaScript安全范围），保持为字符串以避免精度丢失
                if (IsNumericString(stringValue) && !IsVeryLargeNumber(stringValue))
                {
                    sb.Append(stringValue);
                }
                else if (IsNumericString(stringValue))
                {
                    // 数字太大，导出为字符串但添加注释说明
                    sb.Append($"'{stringValue}' --[[ Large Number: {stringValue} ]]");
                }
                else
                {
                    sb.Append($"'{stringValue.Replace("'", "\\''").Replace("\\", "\\\\").Replace("\n", "\\n").Replace("\r", "")}'");
                }
            }
            else if (type == typeof(bool))
            {
                sb.Append(value.ToString().ToLower());
            }
            else if (type.IsPrimitive)
            {
                sb.Append(value);
            }
            else if (type.IsEnum)
            {
                var enumValue = Convert.ToInt32(value);
                var enumName = value.ToString();
                
                // 特殊处理：如果枚举名称为"空"，导出为nil
                if (enumName == "空")
                {
                    sb.Append("nil");
                }
                else
                {
                    sb.Append($"'{enumName}'");
                }
            }
            else if (type == typeof(Vector3))
            {
                var v = (Vector3)value;
                sb.Append($"{{ {v.x}, {v.y}, {v.z} }}");
            }
            else if (value is ScriptableObject so)
            {
                sb.Append(so != null ? $"'{so.name}'" : "nil");
            }
            else if (value is GameObject go)
            {
                sb.Append(go != null ? $"'{go.name}'" : "nil");
            }
            else if (value is RuntimeAnimatorController rac)
            {
                sb.Append(rac != null ? $"'{rac.name}'" : "nil");
            }
            else if (value is IDictionary dictionary)
            {
                sb.AppendLine("{");
                foreach (DictionaryEntry entry in dictionary)
                {
                    sb.Append(new string(' ', (indentLevel + 1) * 2));
                    sb.Append($"[{ValueToLuaString(entry.Key, indentLevel + 1)}] = ");
                    ValueToLua(entry.Value, sb, indentLevel + 1, null);
                    sb.AppendLine(",");
                }
                sb.Append(indent + "}");
            }
            else if (value is IEnumerable enumerable and not string)
            {
                sb.AppendLine("{");
                foreach (var item in enumerable)
                {
                    sb.Append(new string(' ', (indentLevel + 1) * 2));
                    ValueToLua(item, sb, indentLevel + 1, null);
                    sb.AppendLine(",");
                }
                sb.Append(indent + "}");
            }
            else if (type.IsValueType && !type.IsPrimitive || type.IsClass)
            {
                sb.AppendLine("{");
                ObjectToLua(value, sb, indentLevel + 1);
                sb.Append(indent + "}");
            }
            else
            {
                sb.Append("nil --[[ Unhandled Type: " + type.Name + " ]]");
            }
        }

        /// <summary>
        /// 将值转换为Lua字符串格式（用于字典键）
        /// </summary>
        /// <param name="value">要转换的值</param>
        /// <param name="indentLevel">缩进级别</param>
        /// <returns>Lua格式的字符串</returns>
        private string ValueToLuaString(object value, int indentLevel)
        {
            if (value == null) return "nil";
            
            var type = value.GetType();
            
            if (type == typeof(string))
            {
                var stringValue = value.ToString();
                return $"'{stringValue.Replace("'", "\\''").Replace("\\", "\\\\").Replace("\n", "\\n").Replace("\r", "")}'";
            }
            else if (type == typeof(bool))
            {
                return value.ToString().ToLower();
            }
            else if (type.IsPrimitive)
            {
                return value.ToString();
            }
            else if (type.IsEnum)
            {
                return $"'{value.ToString()}'";
            }
            else
            {
                return $"'{value.ToString()}'";
            }
        }

        /// <summary>
        /// 检查字符串是否为纯数字（整数或浮点数）
        /// </summary>
        /// <param name="input">要检查的字符串</param>
        /// <returns>如果是纯数字返回true，否则返回false</returns>
        private bool IsNumericString(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return false;

            // 移除前后空白字符
            input = input.Trim();
            
            // 如果字符串以 + 或 - 开头，不当作纯数字处理
            if (input.StartsWith("+") || input.StartsWith("-"))
                return false;
            
            // 检查是否为整数或浮点数
            return double.TryParse(input, out _);
        }
        
        /// <summary>
        /// 检查数字字符串是否超过安全范围，需要特殊处理
        /// </summary>
        /// <param name="numericString">数字字符串</param>
        /// <returns>如果数字过大需要特殊处理返回true</returns>
        private bool IsVeryLargeNumber(string numericString)
        {
            if (string.IsNullOrWhiteSpace(numericString))
                return false;
                
            // 移除前后空白字符
            numericString = numericString.Trim();
            
            // 如果包含小数点，按浮点数处理
            if (numericString.Contains("."))
            {
                // 尝试用decimal解析，decimal比double精度更高
                if (!decimal.TryParse(numericString, out decimal decimalValue))
                    return true; // 无法解析，太大了
                    
                // 检查是否超过JavaScript安全整数范围（Lua中数字最终可能转为JS）
                return Math.Abs(decimalValue) > 9007199254740991m; // 2^53 - 1
            }
            
            // 整数情况：先尝试long，再尝试decimal
            if (long.TryParse(numericString, out _))
            {
                return false; // long范围内，安全
            }
            
            // 超过long，尝试decimal
            if (decimal.TryParse(numericString, out decimal bigDecimal))
            {
                // 检查是否超过JavaScript安全整数范围
                return Math.Abs(bigDecimal) > 9007199254740991m; // 2^53 - 1
            }
            
            // 连decimal都无法解析，确实太大了
            return true;
        }
        
        /// <summary>
        /// 查找并加载指定路径下所有类型为 T 的 .asset 文件。
        /// </summary>
        /// <returns>找到的资产对象列表</returns>
        protected List<T> FindAssets()
        {
            var assetPaths = GetAssetPaths();
            if (assetPaths == null || assetPaths.Length == 0)
            {
                Debug.LogError($"导出器 {GetType().Name} 未指定有效的资产路径 (GetAssetPaths 返回空值)。");
                return new List<T>();
            }

            string[] guids = AssetDatabase.FindAssets($"t:{typeof(T).Name}", assetPaths);

            if (guids.Length == 0)
            {
                Debug.LogWarning($"在路径 '{string.Join(",", assetPaths)}' 中没有找到任何类型为 '{typeof(T).Name}' 的资产。");
            }

            return guids
                .Select(guid => AssetDatabase.GUIDToAssetPath(guid))
                .Select(path => AssetDatabase.LoadAssetAtPath<T>(path))
                .Where(asset => asset != null)
                .ToList();
        }
    }

    /// <summary>
    /// 一个非泛型接口，用于让编辑器窗口可以引用和操作所有类型的导出器，而无需知道它们的具体泛型类型。
    /// </summary>
    public interface IConfigExporter
    {
        Type TargetType { get; }
        void Export(string exportDir);
        string GetAssetPath();
    }
} 